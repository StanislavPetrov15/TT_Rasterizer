#include <Windows.h>
#include <winuser.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include "Parser.c"
#include "Rasterizer.c"

int WindowWidth = 1200;
int WindowHeight = 800;
HWND Window;

LRESULT CALLBACK EventHandler(HWND, UINT, WPARAM, LPARAM);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hinstance, LPSTR lpstr, int n)
{
    SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_SYSTEM_AWARE); //needed for correct visualization

    WNDCLASS wc = {};
    wc.lpfnWndProc = EventHandler;
    wc.hInstance = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszClassName = "Window";
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.lpszMenuName = NULL;

    RegisterClass(&wc);
    Window = CreateWindow("Window", "Window", (WS_POPUP | WS_MINIMIZEBOX), 100, 100, WindowWidth, WindowHeight, NULL, NULL, hInstance, NULL);

    ShowWindow(Window, SW_NORMAL);

    MSG message;
    while (GetMessage(&message, NULL, 0, 0))
    {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }

    return 0;
}

LRESULT CALLBACK EventHandler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    if (message == WM_SIZE)
    {
        RECT clientRectangle;
        GetClientRect(hwnd, &clientRectangle);
    }
    else if (message == WM_DISPLAYCHANGE)
    {
        UpdateWindow(hwnd);
    }
    else if (message == WM_PAINT)
    {
        RECT rc;
        GetClientRect(Window, &rc);
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(Window, &ps);

        BITMAPINFOHEADER header;
        header.biSize = sizeof(BITMAPINFOHEADER);
        header.biWidth = WindowWidth;
        header.biHeight = WindowHeight;
        header.biPlanes = 1;
        header.biBitCount = 32;
        header.biCompression = BI_RGB;
        header.biSizeImage = 0;
        header.biClrUsed = 0;
        header.biClrImportant = 0;

        struct Font* font;
        FILE* file = NULL;
        wchar_t* filename = L"D:\\Fonts\\arial.ttf"; //(!!!) SET PATH TO THE .ttf FILE HERE
        _wfopen_s(&file, filename, L"rb");
        font = ParseFont(file);

        unsigned char* TT_Canvas = malloc(WindowWidth * WindowHeight * 4);

        for (int i = 0; i < WindowWidth * WindowHeight * 4; i++)
        {
            TT_Canvas[i] = 255;
        }

        const tt_rgba* color1 = C_CORNFLOWER_BLUE;
        const tt_rgba* color2 = C_GOLDENROD;
        const tt_rgba* color3 = C_PURPLE;
        const tt_rgba* color4 = C_INDIAN_RED;

        tt_rgba colors[4];
        colors[0] = *color1;
        colors[1] = *color2;
        colors[2] = *color3;
        colors[3] = *color4;

       DrawString(
           L"solid-identical mode",
           font,
           TT_Canvas, //byte array where the drawing occurs
           BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
           WindowWidth, //canvas width
           WindowHeight, //canvas height
           30, //x (in pixels)
           30, //y (in pixels)
           60, //size (in pixels)
           SCM_SOLID_IDENTICAL, //colorization mode
           colors,
           4, //number of colors,
           0, //transparency
           -1); //max graphemic X

        DrawString(
            L"solid-individual mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            130, //y (in pixels)
            60, //size (in pixels)
            SCM_SOLID_INDIVIDUAL, //colorization mode
            colors,
            4, //number of colors
            0, //transparency
            -1); //max graphemic X

        DrawString(
            L"solid-word mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            230, //y (in pixels)
            60, //size (in pixels)
            SCM_SOLID_WORD, //colorization mode
            colors,
            2, //number of colors
            0, //transparency
            -1); //max graphemic X

        DrawString(
            L"solid-horizontal-gradient-glyph mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            330, //y (in pixels)
            60, //size (in pixels)
            SCM_HORIZONTAL_GRADIENT_GLYPH, //colorization mode
            colors,
            2, //number of colors
            0, //transparency
            -1); //max graphemic X

        DrawString(
            L"solid-vertical-gradient-glyph mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            430, //y (in pixels)
            60, //size (in pixels)
            SCM_VERTICAL_GRADIENT_GLYPH, //colorization mode
            colors,
            2, //number of colors
            0, //transparency
            -1); //max graphemic X

        DrawString(
            L"solid-horizontal-gradient-string mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            530, //y (in pixels)
            60, //size (in pixels)
            SCM_HORIZONTAL_GRADIENT_STRING, //colorization mode
            colors,
            4, //number of colors
            0, //transparency
            -1); //max graphemic X

        DrawString(
            L"solid-vertical-gradient-string mode",
            font,
            TT_Canvas, //byte array where the drawing occurs
            BGRA_ORDER, //SetDIBitsToDevice() uses BGR order
            WindowWidth, //canvas width
            WindowHeight, //canvas height
            30, //x (in pixels)
            630, //y (in pixels)
            60, //size (in pixels)
            SCM_VERTICAL_GRADIENT_STRING, //colorization mode
            colors,
            4, //number of colors
            0, //transparency
            -1); //max graphemic X

        SetDIBitsToDevice(hdc, 0, 0, WindowWidth, WindowHeight, 0, 0, 0, WindowHeight, TT_Canvas, (BITMAPINFO*)&header, DIB_RGB_COLORS);

        ReleaseFont(font);

        EndPaint(hwnd, &ps);

        return 0;
    }
    else if (message == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProcW(hwnd, message, wParam, lParam);
}

